{% extends 'base.html' %}

{% block title %}Algorithm Analysis | SentinelDDoS{% endblock %}

{% block content %}
<div class="container mt-4">
  <h1 class="mb-4">Algorithm Analysis and Implementation</h1>
  
  <div class="alert alert-info">
    <p class="mb-0">This page demonstrates the advanced algorithms and data structures used in the SentinelDDoS system and provides a formal analysis of their time and space complexity.</p>
  </div>

  <div class="row">
    <div class="col-md-12">
      <div class="card mb-4">
        <div class="card-header">
          <h2 class="mb-0">System Architecture Overview</h2>
        </div>
        <div class="card-body">
          <div class="row">
            <div class="col-md-8">
              <p>The SentinelDDoS system is built with a modular architecture consisting of several key components:</p>
              <ul>
                <li><strong>Traffic Profiler</strong>: Monitors incoming requests and extracts metrics</li>
                <li><strong>Anomaly Detector</strong>: Analyzes traffic patterns to identify potential attacks</li>
                <li><strong>Mitigation System</strong>: Applies appropriate countermeasures based on threat assessment</li>
                <li><strong>Attack Simulator</strong>: Generates realistic attack traffic for testing and demonstration</li>
              </ul>
            </div>
            <div class="col-md-4">
              <div class="text-center">
                <svg width="100%" height="200" viewBox="0 0 400 200">
                  <!-- Architecture Diagram -->
                  <rect x="50" y="20" width="300" height="40" rx="5" fill="#6c757d" />
                  <text x="200" y="45" text-anchor="middle" fill="white">Traffic Profiler</text>
                  
                  <rect x="50" y="80" width="300" height="40" rx="5" fill="#17a2b8" />
                  <text x="200" y="105" text-anchor="middle" fill="white">Anomaly Detector</text>
                  
                  <rect x="50" y="140" width="300" height="40" rx="5" fill="#dc3545" />
                  <text x="200" y="165" text-anchor="middle" fill="white">Mitigation System</text>
                  
                  <!-- Arrows connecting components -->
                  <path d="M200 60 L200 80" stroke="white" stroke-width="2" marker-end="url(#arrow)" />
                  <path d="M200 120 L200 140" stroke="white" stroke-width="2" marker-end="url(#arrow)" />
                  
                  <!-- Arrow marker definition -->
                  <defs>
                    <marker id="arrow" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth">
                      <path d="M0,0 L0,6 L9,3 z" fill="white" />
                    </marker>
                  </defs>
                </svg>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="row">
    <div class="col-md-6">
      <div class="card mb-4">
        <div class="card-header">
          <h3 class="mb-0">1. Sliding Window Algorithm</h3>
        </div>
        <div class="card-body">
          <h5>Implementation</h5>
          <p>Used in the Traffic Profiler for efficient tracking of recent requests:</p>
          <pre class="bg-dark text-light p-3"><code>class SlidingWindowCounter:
    def __init__(self, window_size=60):
        self.window_size = window_size  # in seconds
        self.buckets = {}  # timestamp -> count
        
    def increment(self, amount=1):
        current_time = time.time()
        self._cleanup(current_time)
        
        self.buckets[current_time] = self.buckets.get(current_time, 0) + amount
        
    def get_count(self):
        self._cleanup(time.time())
        return sum(self.buckets.values())</code></pre>
          
          <h5>Complexity Analysis</h5>
          <ul>
            <li><strong>Time Complexity</strong>: 
              <ul>
                <li>Increment: O(1) amortized</li>
                <li>Get Count: O(k) where k is the number of time buckets in the window</li>
              </ul>
            </li>
            <li><strong>Space Complexity</strong>: O(w) where w is the window size in seconds</li>
          </ul>
          
          <h5>Advantages</h5>
          <ul>
            <li>Constant-time insertion</li>
            <li>Automatic expiry of old data</li>
            <li>No need to store all individual requests</li>
          </ul>
        </div>
      </div>
    </div>
    
    <div class="col-md-6">
      <div class="card mb-4">
        <div class="card-header">
          <h3 class="mb-0">2. Entropy-Based Detection</h3>
        </div>
        <div class="card-body">
          <h5>Implementation</h5>
          <p>Used in Anomaly Detection to measure randomness in IP distributions:</p>
          <pre class="bg-dark text-light p-3"><code>def _entropy_based_detection(self, metrics):
    """
    Shannon entropy calculation:
    H(X) = -sum(p_i * log2(p_i)) for all i
    
    Where p_i is the probability of seeing IP i
    Low entropy = few IPs dominate (potential DDoS)
    High entropy = many different IPs (normal traffic)
    """
    entropy = metrics.get('entropy_value', 0)
    normalized_entropy = min(1.0, max(0, entropy / 8.0))
    
    # Inverse the score (low entropy = high anomaly)
    anomaly_score = 1.0 - normalized_entropy
    return anomaly_score</code></pre>
          
          <h5>Complexity Analysis</h5>
          <ul>
            <li><strong>Time Complexity</strong>: O(n) where n is the number of unique IPs</li>
            <li><strong>Space Complexity</strong>: O(n) to store the frequency distribution</li>
          </ul>
          
          <h5>Mathematical Foundation</h5>
          <p>Based on Shannon's Information Theory, entropy measures the randomness or unpredictability in a distribution. In DDoS detection, a sudden drop in entropy often indicates an attack.</p>
        </div>
      </div>
    </div>
  </div>
  
  <div class="row">
    <div class="col-md-6">
      <div class="card mb-4">
        <div class="card-header">
          <h3 class="mb-0">3. LRU Cache Implementation</h3>
        </div>
        <div class="card-body">
          <h5>Implementation</h5>
          <p>Used in the Mitigation System for efficient tracking of IP addresses:</p>
          <pre class="bg-dark text-light p-3"><code>class LRUCache:
    """
    LRU Cache with O(1) operations using a doubly-linked list
    and a dictionary for direct access.
    """
    def __init__(self, capacity):
        self.capacity = capacity
        self.cache = {}  # key -> [value, node]
        self.head = Node(0, 0)  # dummy head
        self.tail = Node(0, 0)  # dummy tail
        self.head.next = self.tail
        self.tail.prev = self.head
        self.size = 0
        
    def get(self, key):
        if key in self.cache:
            # Move to front (most recently used)
            node = self.cache[key][1]
            self._remove(node)
            self._add(node)
            return self.cache[key][0]
        return -1
        
    def put(self, key, value):
        if key in self.cache:
            self._remove(self.cache[key][1])
        
        node = Node(key, value)
        self._add(node)
        self.cache[key] = [value, node]
        self.size += 1
        
        # Remove least recently used item
        if len(self.cache) > self.capacity:
            lru = self.head.next
            self._remove(lru)
            del self.cache[lru.key]
            self.size -= 1</code></pre>
          
          <h5>Complexity Analysis</h5>
          <ul>
            <li><strong>Time Complexity</strong>: O(1) for both get and put operations</li>
            <li><strong>Space Complexity</strong>: O(n) where n is the capacity of the cache</li>
          </ul>
          
          <h5>Application in DDoS Defense</h5>
          <p>Efficiently tracks the most recent IP addresses without having to scan through the entire history, allowing for quick access patterns analysis.</p>
        </div>
      </div>
    </div>
    
    <div class="col-md-6">
      <div class="card mb-4">
        <div class="card-header">
          <h3 class="mb-0">4. Graph-Based Analysis</h3>
        </div>
        <div class="card-body">
          <h5>Implementation</h5>
          <p>Used for advanced network behavior modeling:</p>
          <pre class="bg-dark text-light p-3"><code>class IPNode:
    """
    Node for IP address in the attack graph.
    Used for graph-based analysis of attack patterns.
    """
    def __init__(self, ip_address):
        self.ip_address = ip_address
        self.connections = {}  # other_ip -> weight
        self.weight = 0.0  # importance weight
        
    def add_connection(self, other_ip):
        if other_ip not in self.connections:
            self.connections[other_ip] = 0
        self.connections[other_ip] += 1
        
    def update_weight(self, delta):
        # Amortized weight update
        self.weight = (self.weight * 0.95) + (delta * 0.05)</code></pre>
          
          <h5>Complexity Analysis</h5>
          <ul>
            <li><strong>Time Complexity</strong>: O(1) for node operations</li>
            <li><strong>Space Complexity</strong>: O(E) where E is the number of edges (connections)</li>
          </ul>
          
          <h5>Graph Theory Application</h5>
          <p>Allows for detecting coordinated attacks by identifying unusual connection patterns between IPs. The graph structure can reveal attack infrastructure that might not be apparent from analyzing individual requests.</p>
        </div>
      </div>
    </div>
  </div>
  
  <div class="row">
    <div class="col-md-6">
      <div class="card mb-4">
        <div class="card-header">
          <h3 class="mb-0">5. Machine Learning Detection</h3>
        </div>
        <div class="card-body">
          <h5>Implementation</h5>
          <p>Uses Isolation Forest for anomaly detection:</p>
          <pre class="bg-dark text-light p-3"><code>def _ml_based_detection(self):
    """
    Detect anomalies using Isolation Forest algorithm.
    
    Time Complexity: O(t * n * log(n)) where:
    - t = number of trees
    - n = sample size
    
    Space Complexity: O(t * n)
    """
    # Check if we have enough data points to train
    if len(self.recent_metrics) < 10:
        return 0.0
        
    # Extract feature matrix
    features = []
    for m in self.recent_metrics:
        features.append([
            m.get('requests_per_second', 0),
            m.get('unique_ips', 0),
            m.get('entropy_value', 0),
            m.get('burst_score', 0)
        ])
    
    # Train Isolation Forest model
    model = IsolationForest(contamination=0.1)
    model.fit(features)
    
    # Get anomaly score for current metrics
    current = [
        self.current_metrics.get('requests_per_second', 0),
        self.current_metrics.get('unique_ips', 0),
        self.current_metrics.get('entropy_value', 0),
        self.current_metrics.get('burst_score', 0)
    ]
    
    # Predict and normalize score (0 to 1)
    scores = model.decision_function([current])
    normalized_score = 1.0 - ((scores[0] + 0.5) / 1.0)
    return max(0.0, min(1.0, normalized_score))</code></pre>
          
          <h5>Complexity Analysis</h5>
          <ul>
            <li><strong>Time Complexity</strong>: 
              <ul>
                <li>Training: O(t * n * log(n))</li>
                <li>Prediction: O(t * log(n))</li>
              </ul>
            </li>
            <li><strong>Space Complexity</strong>: O(t * n)</li>
          </ul>
          
          <h5>Algorithm Selection Rationale</h5>
          <p>Isolation Forest is particularly suitable for DDoS detection because:</p>
          <ul>
            <li>Efficient with high-dimensional data</li>
            <li>Handles multimodal distributions well</li>
            <li>Low computational complexity compared to other anomaly detection methods</li>
            <li>Does not rely on distance or density measures</li>
          </ul>
        </div>
      </div>
    </div>
    
    <div class="col-md-6">
      <div class="card mb-4">
        <div class="card-header">
          <h3 class="mb-0">6. Priority Queue for Threat Management</h3>
        </div>
        <div class="card-body">
          <h5>Implementation</h5>
          <p>Efficiently prioritizes threats for mitigation:</p>
          <pre class="bg-dark text-light p-3"><code>def mitigate(self, ip_address, anomaly_score):
    """
    Apply mitigation strategies based on anomaly score.
    
    Time Complexity: O(log n) where n is number of threat entries
    Space Complexity: O(n) - linear with tracked IPs
    """
    # Calculate combined threat score
    threat_score = self._calculate_combined_threat(
        ip_address, anomaly_score, self.ip_counters.get(ip_address, 0)
    )
    
    # Update priority queue (min-heap implementation)
    if ip_address in self.threat_heap:
        # Update existing entry
        for i, (score, ip, timestamp) in enumerate(self.threat_heap):
            if ip == ip_address:
                # Remove old entry
                self.threat_heap[i] = self.threat_heap[-1]
                self.threat_heap.pop()
                heapq.heapify(self.threat_heap)
                break
    
    # Add new entry to heap
    heapq.heappush(
        self.threat_heap, 
        (threat_score, ip_address, time.time())
    )
    
    # Apply appropriate mitigation based on threat score
    if threat_score > self.severe_threshold:
        return self._block_ip(ip_address, 'severe')
    elif threat_score > self.medium_threshold:
        return self._challenge_ip(ip_address)
    elif threat_score > self.light_threshold:
        return self._rate_limit_ip(ip_address)
    return 'none'</code></pre>
          
          <h5>Complexity Analysis</h5>
          <ul>
            <li><strong>Time Complexity</strong>: 
              <ul>
                <li>Insert/Update: O(log n)</li>
                <li>Get Highest Threat: O(1)</li>
                <li>Remove: O(log n)</li>
              </ul>
            </li>
            <li><strong>Space Complexity</strong>: O(n) where n is the number of tracked threats</li>
          </ul>
          
          <h5>Heap Data Structure Benefits</h5>
          <p>The binary heap implementation provides efficient prioritization of threats while maintaining logarithmic time complexity for operations, allowing the system to scale to handle large numbers of potential threats.</p>
        </div>
      </div>
    </div>
  </div>
  
  <div class="row">
    <div class="col-md-12">
      <div class="card mb-4">
        <div class="card-header">
          <h3 class="mb-0">Amortized Analysis and System Efficiency</h3>
        </div>
        <div class="card-body">
          <h5>Amortized Cost Analysis</h5>
          <p>Several operations in the system use amortized analysis techniques:</p>
          
          <div class="table-responsive">
            <table class="table table-bordered">
              <thead class="table-dark">
                <tr>
                  <th>Operation</th>
                  <th>Worst-Case Complexity</th>
                  <th>Amortized Complexity</th>
                  <th>Implementation Technique</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>Sliding Window Cleanup</td>
                  <td>O(n) where n is window size</td>
                  <td>O(1) per operation</td>
                  <td>Lazy deletion with periodic cleanup</td>
                </tr>
                <tr>
                  <td>LRU Cache Maintenance</td>
                  <td>O(n) for full restructure</td>
                  <td>O(1) per operation</td>
                  <td>Doubly-linked list with hash map</td>
                </tr>
                <tr>
                  <td>IP Node Weight Updates</td>
                  <td>O(n) for full recalculation</td>
                  <td>O(1) per update</td>
                  <td>Exponential moving average</td>
                </tr>
                <tr>
                  <td>Threat Queue Cleanup</td>
                  <td>O(n log n) for full rebuild</td>
                  <td>O(log n) per operation</td>
                  <td>Periodic heap maintenance</td>
                </tr>
              </tbody>
            </table>
          </div>
          
          <h5>System Efficiency Metrics</h5>
          <div class="row mt-4">
            <div class="col-md-4">
              <div class="card bg-dark text-white">
                <div class="card-body text-center">
                  <h3>O(1)</h3>
                  <p>Amortized cost for most frequent operations</p>
                </div>
              </div>
            </div>
            <div class="col-md-4">
              <div class="card bg-dark text-white">
                <div class="card-body text-center">
                  <h3>O(log n)</h3>
                  <p>Time complexity for threat processing</p>
                </div>
              </div>
            </div>
            <div class="col-md-4">
              <div class="card bg-dark text-white">
                <div class="card-body text-center">
                  <h3>O(n)</h3>
                  <p>Linear space complexity with respect to traffic</p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>
{% endblock %}